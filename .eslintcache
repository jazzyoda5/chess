[{"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/index.js":"1","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/App.js":"2","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/reportWebVitals.js":"3","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/board.js":"4","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/menu.js":"5","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/offline_board.js":"6","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/panel.js":"7","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/choose_pawn.js":"8","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/extras.js":"9","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/square.js":"10","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/checkmate_dialog.js":"11","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/socket/socket.js":"12","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/choose_color_dialog.js":"13","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/register.js":"14","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/login.js":"15","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/private_route.js":"16","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/leaderboard.js":"17"},{"size":545,"mtime":1610302527891,"results":"18","hashOfConfig":"19"},{"size":1397,"mtime":1614520255230,"results":"20","hashOfConfig":"19"},{"size":362,"mtime":1610302527891,"results":"21","hashOfConfig":"19"},{"size":20824,"mtime":1614523705834,"results":"22","hashOfConfig":"19"},{"size":4516,"mtime":1614527013398,"results":"23","hashOfConfig":"19"},{"size":15824,"mtime":1610804609547,"results":"24","hashOfConfig":"19"},{"size":1204,"mtime":1610711122014,"results":"25","hashOfConfig":"19"},{"size":2160,"mtime":1610551279369,"results":"26","hashOfConfig":"19"},{"size":10391,"mtime":1614085183095,"results":"27","hashOfConfig":"19"},{"size":2517,"mtime":1610302527890,"results":"28","hashOfConfig":"19"},{"size":1417,"mtime":1614085202678,"results":"29","hashOfConfig":"19"},{"size":146,"mtime":1610479328131,"results":"30","hashOfConfig":"19"},{"size":1326,"mtime":1610719023358,"results":"31","hashOfConfig":"19"},{"size":4611,"mtime":1614517142879,"results":"32","hashOfConfig":"19"},{"size":3957,"mtime":1614517160100,"results":"33","hashOfConfig":"19"},{"size":330,"mtime":1614520104993,"results":"34","hashOfConfig":"19"},{"size":2738,"mtime":1614526990990,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"ruvln2",{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"38"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"38"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/index.js",[],["73","74"],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/App.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/reportWebVitals.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/board.js",["75"],"import {\n  Button,\n  Typography,\n  Dialog,\n  DialogActions,\n  DialogContentText,\n  DialogContent,\n  DialogTitle,\n} from \"@material-ui/core\";\nimport CircularProgress from \"@material-ui/core/CircularProgress\";\nimport \"fontsource-roboto\";\nimport React, { useEffect, useState, useRef } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport \"../static/style.css\";\nimport Square from \"./square\";\nimport Panel from \"./panel.js\";\nimport PawnDialog from \"./choose_pawn.js\";\nimport CheckmateDialog from \"./checkmate_dialog\";\nimport { socket } from '../socket/socket';\n\nconst extras = require(\"./extras.js\");\n\nconst letters = \"abcdefgh\";\n\n// Multiplayer game\nfunction Board(props) {\n  const [clicked_square, set_clicked_square] = useState(null);\n  const [game_state, set_game_state] = useState(extras.newGame());\n  const [next_move, set_next_move] = useState(\"White\");\n  const [check, set_check] = useState(null);\n  const [valid_moves, set_valid_moves] = useState([]);\n  const [room_id, _set_room_id] = useState(null);\n  const [color, set_color] = useState(null);\n  // Opponent -> 0 == false, 1 == true, 2 == opponent left\n  const [opponent, set_opponent] = useState(0);\n  const [opponent_name, set_opponent_name] = useState(null);\n  // Dialog for if opponent leaves\n  const [open, setOpen] = useState(false);\n  // end_w and end_b tell the board if a pawn has reached the end\n  const [end_w, set_end_w] = useState(null);\n  const [end_b, set_end_b] = useState(null);\n  // This solves an error that occured when finding valid_moves after castling\n  // So after a user has castled, it doesn't try to see, if castling is still possible\n  const [already_castled, set_castled] = useState(false);\n  const [checkmate, set_checkmate] = useState(false);\n\n\n  // To avoid being stranded if opponent\n  // Closes browser window mid game\n  // Handle function is on the bottom\n  // Of the file\n  const roomIdRef = useRef(room_id);\n  const set_room_id = (data) => {\n    roomIdRef.current = data;\n    _set_room_id(data);\n  };\n\n  // Run only once to join the game\n  useEffect(() => {\n    console.log(\"[SOCKET] Joining a game.\");\n    socket.emit(\"join\");\n\n    // SOCKET\n    socket.on(\"connect\", () => {\n      console.log(\"[SOCKET] Is connected.\");\n    });\n\n    // If opponent is found\n    // Or if he left\n    socket.on(\"opponent\", (message) => {\n      console.log(\"[SOCKET] Opponent found.\");\n\n      if (message === \"left\") {\n        set_opponent(2);\n        setOpen(true);\n      }\n    });\n\n    // Game can begin\n    socket.on(\"full-room\", () => {\n      set_opponent(1);\n    });\n\n    socket.on(\"move\", (data) => {\n      let new_state = JSON.parse(data[\"JSON_game_state\"]);\n      // Set game state\n      set_game_state(new_state);\n      // Set next_move\n      set_next_move(data[\"n_move\"]);\n      set_check(data[\"check\"]);\n    });\n\n    // When you joing a game you recieve data about the game\n    socket.on(\"room-data\", (data) => {\n      let room_id1 = data[\"room_id\"];\n      let color1 = data[\"color\"];\n      set_room_id(room_id1);\n      set_color(color1);\n    });\n\n    socket.on(\"message\", (data) => {\n      console.log(`[SOCKET] Message recieved ${data}`);\n    });\n\n    socket.on('checkmate', (data) => {\n      set_game_state(data['game_state']);\n      set_checkmate(data['checkmate']);\n    })\n  }, []);\n\n  const getRow = (num) => {\n    let row = [];\n\n    for (let i = 0; i <= 7; i++) {\n      let tag = letters[i] + num.toString();\n      row.push({\n        tag: tag,\n      });\n    }\n    return row;\n  };\n\n  const getBoardData = () => {\n    let board_data = [];\n    for (let i = 0; i <= 7; i++) {\n      let row = getRow(i + 1);\n      board_data.push(row);\n    }\n    return board_data;\n  };\n\n  const getSquareValue = (tag) => {\n    // Get i\n    let i = tag[1] - 1;\n\n    // Get j\n    let j = letters.indexOf(tag[0]);\n\n    let value = game_state[i][j];\n    return value;\n  };\n\n  const handleClick = (tag) => {\n    // Only do anything if it is user's turn to play\n    if (next_move === color) {\n      /*\n          - pawn is the value of previosly chosen square\n          - value is the value of second chosen square!\n          */\n\n      // coordinates of clicked square\n      let coor_x = letters.indexOf(tag[0]);\n      let coor_y = tag[1] - 1;\n\n      // Game state\n      var local_game_state = JSON.parse(JSON.stringify(game_state));\n      // Get pawn in the square that is clicked\n      const value = local_game_state[coor_y][coor_x];\n\n      // Whose move it is\n      let next_move1 = next_move[0].toLowerCase();\n\n      // If no pawn has been chosen in previou click, choose a pawn\n      if (clicked_square === null && value !== \"\" && value[0] === next_move1) {\n        // Set clicked_square in state\n        // Set valid next moves in state\n        const vm = getValidMoves(coor_x, coor_y, value, local_game_state);\n        console.log(\"vm\", vm);\n\n        set_clicked_square([coor_x, coor_y]);\n        set_valid_moves(v_moves(local_game_state, vm, coor_x, coor_y, value));\n      }\n\n      // If pawn was already previously chosen, make a move\n      else if (clicked_square !== null) {\n        // Get coor of previously chosen pawn\n        let pawn_x = clicked_square[0];\n        let pawn_y = clicked_square[1];\n\n        // Now get previously chosen pawn value\n        let pawn = local_game_state[pawn_y][pawn_x];\n        // !!! What to do depends on value on chosen square\n\n        // if chosen pawn and clicked pawn are same color\n        if (value[0] === pawn[0]) {\n          set_clicked_square([coor_x, coor_y]);\n          const vm = getValidMoves(coor_x, coor_y, value, local_game_state);\n          console.log(\"vm\", vm);\n\n          // If clicked pawn is your playing color than get valid moves\n          // This if statement fixes some bugs where\n          // You could move other player's pawns\n          if (value[0] === color[0].toLowerCase()) {\n            set_valid_moves(v_moves(local_game_state, vm, coor_x, coor_y, value));\n          } else {\n            set_valid_moves([]);\n          }\n        } else {\n          // If move is valid\n          if (extras.check_if_valid_move(coor_x, coor_y, valid_moves)) {\n            /* If the previous move checked the opponent\n              opponent must make sure his next move\n              unchecks his king\n          */\n            // Check if it is a pawn that reached the end\n            // Of the board\n            let n_move = \"\";\n            if (color === \"White\") {\n              n_move = \"Black\";\n            } else {\n              n_move = \"White\";\n            }\n\n            // Check if castling\n            const castling = extras.check_if_castling(\n              coor_x,\n              coor_y,\n              pawn_x,\n              pawn_y,\n              pawn,\n              local_game_state\n            );\n            console.log(castling);\n            if (castling !== false) {\n              /*\n              Castling is handled by a different\n              method than making a move\n              */\n              handleCastling(castling, local_game_state, n_move);\n              return;\n            }\n\n            if (pawn === \"wP\" && coor_y === 0) {\n              set_end_w([\n                coor_x,\n                coor_y,\n                pawn_x,\n                pawn_y,\n                \"wP\",\n                n_move,\n                next_move1,\n              ]);\n              return;\n            }\n            if (pawn === \"bP\" && coor_y === 7) {\n              set_end_b([coor_x, coor_y, \"bP\"]);\n              return;\n            }\n\n            makeMove(\n              coor_x,\n              coor_y,\n              pawn_x,\n              pawn_y,\n              pawn,\n              local_game_state,\n              n_move,\n              next_move1\n            );\n\n            // If move is not valid\n          } else {\n            set_clicked_square([coor_x, coor_y]);\n            const vm = getValidMoves(coor_x, coor_y, value, local_game_state);\n            if (value[0] === color[0].toLowerCase()) {\n              set_valid_moves(\n                v_moves(local_game_state, vm, coor_x, coor_y, value)\n              );\n            } else {\n              set_valid_moves([]);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  const makeMove = (\n    x,\n    y,\n    pawn_x,\n    pawn_y,\n    pawn,\n    local_game_state,\n    n_move,\n    next_move1\n  ) => {\n    // Check variable\n    /* \n    I will emit checks to avoid bugs -> Sometime when users \n    has check state null and the other one doesn't\n    */\n    var check = null;\n    // figure out next move\n    /*\n    Every time there is a check, I will check for checkmate.\n    */\n\n    set_clicked_square(null);\n    set_valid_moves([]);\n    set_game_state(\n      updateGameState(x, y, pawn_x, pawn_y, pawn, local_game_state)\n    );\n\n    if (next_move1 === \"w\") {\n      // White moved, check check on black\n      if (\n        checkCheck(\n          updateGameState(x, y, pawn_x, pawn_y, pawn, local_game_state),\n          \"w\"\n        )\n      ) {\n        handleCheck(\"b\", x, y, pawn_x, pawn_y, pawn, local_game_state);\n        check = \"b\";\n      }\n    } else {\n      // Black moved, check check on white\n      if (\n        checkCheck(\n          updateGameState(x, y, pawn_x, pawn_y, pawn, local_game_state),\n          \"b\"\n        )\n      ) {\n        handleCheck(\"w\", x, y, pawn_x, pawn_y, pawn, local_game_state);\n        check = \"w\";\n      }\n    }\n\n    // emit new game_state through the socket\n    let JSON_game_state = JSON.stringify(local_game_state);\n    socket.emit(\"move\", {\n      JSON_game_state: JSON_game_state,\n      n_move: n_move,\n      check: check,\n      room_id: room_id \n    });\n  };\n\n  const handleCastling = (type, state, n_move) => {\n    if (type === \"wR\") {\n      state[7][4] = \"\";\n      state[7][5] = \"wR\";\n      state[7][6] = \"wK\";\n      state[7][7] = \"\";\n    } else if (type === \"wL\") {\n      state[7][4] = \"\";\n      state[7][3] = \"wR\";\n      state[7][2] = \"wK\";\n      state[7][1] = \"\";\n      state[7][0] = \"\";\n    } else if (type === \"bR\") {\n      state[0][4] = \"\";\n      state[0][5] = \"bR\";\n      state[0][6] = \"bK\";\n      state[0][7] = \"\";\n    } else if (type === \"bL\") {\n      state[0][4] = \"\";\n      state[0][3] = \"bR\";\n      state[0][2] = \"bK\";\n      state[0][1] = \"\";\n      state[0][0] = \"\";\n    }\n\n    set_clicked_square(null);\n    set_valid_moves([]);\n    set_castled(true);\n    set_game_state(state);\n    // emit new game_state through the socket\n    let JSON_game_state = JSON.stringify(state);\n    socket.emit(\"move\", {\n      JSON_game_state: JSON_game_state,\n      n_move: n_move,\n      check: check,\n      room_id: room_id\n    });\n  };\n\n  // This valid moves function is to avoid putting\n  // Your own pieces in check and aking it so\n  // That you have to get out of check with if\n  // Your king is checked\n  const v_moves = (state, moves, x, y, pawn) => {\n    let v_moves = [];\n\n    if (color[0].toLowerCase() !== pawn[0]) {\n      return v_moves;\n    }\n\n    if (pawn[0] === color[0].toLowerCase()) {\n      for (let i = 0; i <= moves.length - 1; i++) {\n        let state_copy = JSON.parse(JSON.stringify(state));\n        let move = moves[i];\n        state_copy[move[1]][move[0]] = pawn;\n        state_copy[y][x] = \"\";\n        let color = \"b\";\n        if (pawn[0] === \"b\") {\n          color = \"w\";\n        }\n        let check = checkCheck(state_copy, color);\n        if (!check) {\n          v_moves.push(move);\n        }\n      }\n    }\n    return v_moves;\n  };\n\n  const getValidMoves = (\n    x,\n    y,\n    pawn,\n    local_game_state,\n    checking_check = false\n  ) => {\n    let valid_moves = [];\n\n    if (pawn[1] === \"P\") {\n      valid_moves = extras.pawn_valid_moves(x, y, pawn, local_game_state);\n    }\n    // For a rook\n    else if (pawn[1] === \"R\") {\n      valid_moves = extras.rook_valid_moves(x, y, pawn, local_game_state);\n    }\n    // For knight\n    else if (pawn[1] === \"K\" && pawn.length > 2) {\n      valid_moves = extras.knight_valid_moves(x, y, pawn, local_game_state);\n    } else if (pawn[1] === \"K\" && pawn.length === 2) {\n      valid_moves = extras.king_valid_moves(x, y, pawn, local_game_state);\n      const c_move = extras.castling_possible(x, y, pawn, local_game_state);\n      if (c_move !== false && !checking_check && !already_castled && c_move !== undefined) {\n        valid_moves.push(c_move);\n      }\n    } else if (pawn[1] === \"B\") {\n      valid_moves = extras.get_bishop_moves(x, y, pawn, local_game_state);\n    }\n    // Queen\n    else if (pawn[1] === \"Q\") {\n      // First get up, down, left, right; just like rook.\n      valid_moves = extras.rook_valid_moves(x, y, pawn, local_game_state);\n      let b_moves = extras.get_bishop_moves(x, y, pawn, local_game_state);\n      for (let i = 0; i <= b_moves.length - 1; i++) {\n        valid_moves.push(b_moves[i]);\n      }\n    }\n    return valid_moves;\n  };\n\n  const checkCheck = (igame_state, color) => {\n    // Get all valid moves\n    // And see if anyone can eat the opponent's king\n    for (let i = 0; i <= igame_state.length - 1; i++) {\n      for (let j = 0; j <= igame_state[i].length - 1; j++) {\n        let pawn = igame_state[i][j];\n\n        if (pawn[0] === color) {\n          let valid_moves = getValidMoves(j, i, pawn, igame_state, true);\n          for (let k = 0; k <= valid_moves.length - 1; k++) {\n            let pawn_on_pos = igame_state[valid_moves[k][1]][valid_moves[k][0]];\n            if (pawn_on_pos[1] === \"K\" && pawn_on_pos.length === 2) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  };\n\n  const checkCheckmate = (state, color) => {\n    console.log('checkmate state: ', state);\n\n    // Get all moves and if there are no possible moves\n    // It is checkmate\n    let valid_moves1 = [];\n    for (let i = 0; i <= 7; i++) {\n      for (let j = 0; j <= 7; j++) {\n        let pawn = state[i][j];\n        if (pawn[0] === color) {\n          const vm = getValidMoves(j, i, pawn, state);\n          let moves = v_moves(state, vm, j, i, pawn);\n          if (moves.length > 0) {\n            for (let x = 0; x <= moves.length - 1; x++) {\n              valid_moves1.push(moves[x]);\n            }\n          }\n        }\n      }\n    }\n    if (valid_moves1.length < 1) {\n      if (color === 'w') {\n        return 'Black';\n      } else {\n        return 'White';\n      }\n    }\n    console.log('c_move checkmate: ', valid_moves1);\n    return false;\n  };\n\n  // Makes a move and returns a new version of game_state\n  const updateGameState = (\n    coor_x,\n    coor_y,\n    pawn_x,\n    pawn_y,\n    pawn,\n    l_game_state\n  ) => {\n    l_game_state[coor_y][coor_x] = pawn;\n    l_game_state[pawn_y][pawn_x] = \"\";\n    return l_game_state;\n  };\n\n  const handleCheck = (given_color, x, y, pawn_x, pawn_y, pawn, lg_state) => {\n    // color = Color of the king that is in danger\n    set_check(given_color);\n\n    // Check for checkmate\n    let mate = checkCheckmate(lg_state, given_color);\n\n    // If checkmate\n    if (mate !== false) {\n      set_checkmate(mate);\n      socket.emit('checkmate', {\n        'game_state': lg_state,\n        'checkmate': mate,\n        'room_id': room_id\n      });\n      // Emit checkmate\n    }\n  };\n\n  /*\n  When valid moves are calculated\n  This function finds the tags of those moves\n  so it can feed it to <Square />\n  */\n  const getTagsOfValidMoves = (valid_moves) => {\n    let tags = [];\n    if (valid_moves.length > 0) {\n      for (let i = 0; i <= valid_moves.length - 1; i++) {\n        let move = valid_moves[i];\n        let y = (move[1] + 1).toString();\n        let x = letters[move[0]];\n        let tag = x + y;\n        tags.push(tag);\n      }\n    }\n    return tags;\n  };\n\n  /*\n  This function switches the pawn\n  for whatever the user chooses \n  after a pawn reaches the end of the board\n  */\n  const switchPawn = (x, y, pawn_x, pawn_y, pawn, next_move1) => {\n    let n_move = \"\";\n    if (color === \"White\") {\n      n_move = \"Black\";\n    } else {\n      n_move = \"White\";\n    }\n    let local_game_state = JSON.parse(JSON.stringify(game_state));\n    makeMove(x, y, pawn_x, pawn_y, pawn, local_game_state, n_move, next_move1);\n    set_end_b(null);\n    set_end_w(null);\n  };\n\n  const handleExit = () => {\n    socket.emit(\"leave\", {\n      room_id: room_id,\n    });\n    // reset component\n    set_room_id(null);\n    set_color(null);\n    set_checkmate(false);\n    set_check(null);\n    set_castled(false);\n    set_next_move('White');\n    set_game_state(extras.newGame());\n  };\n\n  const handleUnload = (event) => {\n    event.preventDefault();\n    event.returnValue = \" \";\n    socket.emit(\"leave\", {\n      room_id: roomIdRef.current,\n    });\n  }\n\n  // Handles closing the browser window\n  useEffect(() => {\n    window.addEventListener(\"beforeunload\", handleUnload);\n\n    return () => {\n      window.removeEventListener(\"beforeunload\", handleUnload);\n    }\n  }, []);\n\n  useEffect(() => {\n    window.onpopstate = () => {\n      socket.emit('leave', {\n        'room_id': roomIdRef.current,\n      })\n      // reset component\n      set_room_id(null);\n      set_color(null);\n      set_checkmate(false);\n      set_check(null);\n      set_castled(false);\n      set_next_move('White');\n      set_game_state(extras.newGame());\n    };\n  }, [])\n\n  const handleFindNewGame = () => {\n    socket.emit(\"leave\", {\n      room_id: room_id,\n    });\n    // No opponent\n    set_opponent(0);\n\n    // reset component\n    set_room_id(null);\n    set_color(null);\n    set_checkmate(false);\n    set_check(null);\n    set_castled(false);\n    set_next_move('White');\n    set_game_state(extras.newGame());\n\n    socket.emit(\"join\");\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n  };\n\n  // Set the board\n  let board_data = getBoardData();\n\n  // Waiting on opponent\n  if (opponent === 0) {\n    return (\n      <div className=\"game\">\n        <div className=\"waiting\">\n          <Typography variant=\"h5\" component=\"h5\" gutterBottom>\n            Searching for an opponent...\n          </Typography>\n          <CircularProgress mode=\"indeterminate\" color=\"#ffffff\" />\n        </div>\n      </div>\n    );\n  }\n  // Opponent found\n  else {\n    return (\n      <div className=\"game\">\n        {end_w ? (\n          <PawnDialog\n            color={\"w\"}\n            open={true}\n            switchPawn={switchPawn}\n            data={end_w}\n          />\n        ) : null}\n        {end_b ? (\n          <PawnDialog\n            color={\"b\"}\n            open={true}\n            switchPawn={switchPawn}\n            data={end_b}\n          />\n        ) : null}\n        {opponent === 2 ? (\n          <div className=\"dialog\">\n            <Dialog\n              open={open}\n              onClose={handleClose}\n              aria-labelledby=\"alert-dialog-title\"\n              aria-describedby=\"alert-dialog-description\"\n              className=\"dialog-dialog\"\n            >\n              <DialogTitle id=\"alert-dialog-title\">\n                {\"Your opponent has left the game.\"}\n              </DialogTitle>\n              <DialogContent>\n                <DialogContentText id=\"alert-dialog-description\">\n                  Would you like to find a new game or exit?\n                </DialogContentText>\n              </DialogContent>\n              <DialogActions>\n                <Button\n                  onClick={() => {\n                    handleFindNewGame();\n                  }}\n                  color=\"primary\"\n                >\n                  Find a New Game\n                </Button>\n                <Button\n                  onClick={handleExit}\n                  component={Link}\n                  to={\"/\"}\n                  color=\"primary\"\n                  autoFocus\n                >\n                  Exit\n                </Button>\n              </DialogActions>\n            </Dialog>\n          </div>\n        ) : null}\n        {checkmate !== false ? (\n          <CheckmateDialog\n            open={true}\n            winner={checkmate}\n            handleExit={handleExit}\n          />\n        ) : null}\n        <Panel\n          set_game_state={set_game_state}\n          set_next_move={set_next_move}\n          handleExit={handleExit}\n          color={color}\n          next_move={next_move}\n          online={true}\n          opponent_name={opponent_name}\n        />\n        <div className=\"board\">\n          <div className=\"squares\">\n            {board_data.map((row) => {\n              return (\n                <div className=\"board-row\">\n                  {row.map((square) => {\n                    return (\n                      <Square\n                        tag={square.tag}\n                        value={getSquareValue(square.tag)}\n                        handleClick={handleClick}\n                        validMoves={getTagsOfValidMoves(valid_moves)}\n                        check={check}\n                      />\n                    );\n                  })}\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Board;\n","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/menu.js",["76","77","78","79","80"],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/offline_board.js",["81"],"import \"fontsource-roboto\";\nimport React, { useState, useEffect } from \"react\";\nimport \"../static/style.css\";\nimport Square from \"./square\";\nimport Panel from \"./panel.js\";\nimport PawnDialog from \"./choose_pawn\";\nimport ChooseColorDialog from \"./choose_color_dialog\";\nimport CheckmateDialog from \"./checkmate_dialog\";\nimport { socket } from \"../socket/socket\";\n\nconst extras = require(\"./extras.js\");\n\nconst letters = \"abcdefgh\";\n\n/*\nThere will be two options:\n- To choose a 2-player offline game\n- To play against the computer\n*/\n\nfunction OfflineBoard(props) {\n  const [clicked_square, set_clicked_square] = useState(null);\n  const [game_state, set_game_state] = useState(extras.newGame());\n  const [next_move, set_next_move] = useState(\"White\");\n  const [check, set_check] = useState(null);\n  const [valid_moves, set_valid_moves] = useState([]);\n  const [end_w, set_end_w] = useState(null);\n  const [end_b, set_end_b] = useState(null);\n  const [checkmate, set_checkmate] = useState(false);\n  const [comp_color, set_comp_color] = useState(null);\n  const [player_color, set_player_color] = useState(null);\n\n  useEffect(() => {\n    socket.on(\"computer-move\", (data) => {\n      console.log(\"[SOCKET] Recieved a move from the server.\");\n      // Make a move\n      if (data) {\n        makeComputerMove(data);\n      } else {\n        console.log('[SOCKET] Data recieved is not valid.');\n      }\n    });\n  }, [comp_color]);\n\n  const getRow = (num) => {\n    let row = [];\n\n    for (let i = 0; i <= 7; i++) {\n      let tag = letters[i] + num.toString();\n      row.push({\n        tag: tag,\n      });\n    }\n    return row;\n  };\n\n  const getBoardData = () => {\n    let board_data = [];\n    for (let i = 0; i <= 7; i++) {\n      let row = getRow(i + 1);\n      board_data.push(row);\n    }\n    return board_data;\n  };\n\n  const getSquareValue = (tag) => {\n    // Get i\n    const i = tag[1] - 1;\n\n    // Get j\n    const j = letters.indexOf(tag[0]);\n\n    const value = game_state[i][j];\n\n    return value;\n  };\n\n  function handleClick(tag) {\n    if (props.mode !== \"1player\" || next_move === player_color) {\n      // Make a copy of the game_state\n      const local_game_state = JSON.parse(JSON.stringify(game_state));\n\n      /*\n            - pawn is the value of previosly chosen square\n            - value is the value of second chosen square!\n            */\n\n      // coordinates of clicked square\n      const coor_x = letters.indexOf(tag[0]);\n      const coor_y = tag[1] - 1;\n\n      // Get pawn in the square that is clicked\n      const value = local_game_state[coor_y][coor_x];\n\n      // Whose move it is\n      let next_move1 = next_move[0].toLowerCase();\n\n      // If no pawn has been chosen in previou click, choose a pawn\n      if (clicked_square === null && value !== \"\" && value[0] === next_move1) {\n        // Set clicked_square in state\n        // Set valid next moves in state\n        const vm = getValidMoves(coor_x, coor_y, value, local_game_state);\n        set_clicked_square([coor_x, coor_y]);\n        set_valid_moves(v_moves(local_game_state, vm, coor_x, coor_y, value));\n      }\n\n      // If pawn was already previously chosen, make a move\n      else if (clicked_square !== null) {\n        // Get coor of previously chosen pawn\n        var pawn_x = clicked_square[0];\n        var pawn_y = clicked_square[1];\n\n        // Now get previously chosen pawn value\n        var pawn = local_game_state[pawn_y][pawn_x];\n\n        // !!! What to do depends on value on chosen square\n\n        // if chosen pawn and clicked pawn are same color\n        if (value[0] === pawn[0]) {\n          set_clicked_square([coor_x, coor_y]);\n          const vm = getValidMoves(coor_x, coor_y, value, local_game_state);\n          if (value[0] === next_move1) {\n            set_valid_moves(\n              v_moves(local_game_state, vm, coor_x, coor_y, value)\n            );\n          } else if (value[0] !== next_move) {\n            set_valid_moves([]);\n          }\n        } else {\n          // There is no pawn of the samo color on clicked square\n          // Try to make a move\n          if (\n            extras.check_if_valid_move(\n              coor_x,\n              coor_y,\n              valid_moves,\n              local_game_state\n            )\n          ) {\n            // Move is valid\n\n            // Castling is handled by a different method\n            // than making a move\n            const castling = extras.check_if_castling(\n              coor_x,\n              coor_y,\n              pawn_x,\n              pawn_y,\n              pawn,\n              local_game_state\n            );\n\n            if (castling !== false) {\n              handleCastling(castling, local_game_state, next_move1);\n              return;\n            }\n\n            // Check if it is a pawn that reached the end\n            // Of the board\n            if (pawn === \"wP\" && coor_y === 0) {\n              set_end_w([coor_x, coor_y, \"wP\"]);\n            }\n            if (pawn === \"bP\" && coor_y === 7) {\n              set_end_b([coor_x, coor_y, \"bP\"]);\n            }\n\n            // figure out next move\n            if (next_move1 === \"w\") {\n              set_next_move(\"Black\");\n            } else {\n              set_next_move(\"White\");\n            }\n            makeMove(coor_x, coor_y, pawn_x, pawn_y, pawn, local_game_state);\n            // If move is not valid\n          } else {\n            console.log(\"else runs\");\n            const vm = getValidMoves(coor_x, coor_y, value, local_game_state);\n\n            set_clicked_square([coor_x, coor_y]);\n            if (value[0] === next_move1) {\n              set_valid_moves(\n                v_moves(local_game_state, vm, coor_x, coor_y, value)\n              );\n            } else {\n              set_valid_moves([]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  const makeMove = (x, y, pawn_x, pawn_y, pawn, local_game_state) => {\n    const updated_game_state = updateGameState(\n      x,\n      y,\n      pawn_x,\n      pawn_y,\n      pawn,\n      local_game_state\n    );\n    set_game_state(updated_game_state);\n    set_clicked_square(null);\n    set_valid_moves([]);\n    // Check for check after making a move\n    let color1 = \"b\";\n    if (pawn[0] === \"b\") {\n      color1 = \"w\";\n    }\n    if (checkCheck(updated_game_state, pawn[0])) {\n      handleCheck(color1, updated_game_state);\n    } else {\n      set_check(null);\n    }\n\n    // If playing against the computer\n    if (props.mode === \"1player\" && !end_b && !end_w) {\n      // Emit the data to the server\n      socket.emit(\"computer-move\", {\n        game_state: updated_game_state,\n        comp_color: comp_color,\n      });\n    }\n  };\n\n  const makeComputerMove = (data) => {\n    if (!checkmate) {\n      let local_game_state = data[\"game_state\"];\n      let color1 = \"b\";\n      let color2 = \"Black\";\n      if (comp_color === \"b\") {\n        color1 = \"w\";\n        color2 = \"White\";\n      }\n\n      set_game_state(local_game_state);\n      set_next_move(color2);\n\n      if (checkCheck(local_game_state, comp_color)) {\n        handleCheck(color1, local_game_state);\n      } else {\n        set_check(null);\n      }\n    }\n  };\n\n  const handleCastling = (type, state, next_move) => {\n    if (type === \"wR\") {\n      state[7][4] = \"\";\n      state[7][5] = \"wR\";\n      state[7][6] = \"wK\";\n      state[7][7] = \"\";\n    } else if (type === \"wL\") {\n      state[7][4] = \"\";\n      state[7][3] = \"wR\";\n      state[7][2] = \"wK\";\n      state[7][1] = \"\";\n      state[7][0] = \"\";\n    } else if (type === \"bR\") {\n      state[0][4] = \"\";\n      state[0][5] = \"bR\";\n      state[0][6] = \"bK\";\n      state[0][7] = \"\";\n    } else if (type === \"bL\") {\n      state[0][4] = \"\";\n      state[0][3] = \"bR\";\n      state[0][2] = \"bK\";\n      state[0][1] = \"\";\n      state[0][0] = \"\";\n    }\n\n    console.log(\"update game state runs\");\n    set_clicked_square(null);\n    set_valid_moves([]);\n    set_game_state(state);\n\n    if (next_move === \"w\") {\n      set_next_move(\"Black\");\n    } else {\n      set_next_move(\"White\");\n    }\n  };\n\n  // This function makes sure\n  // You can't put your self in check\n  const v_moves = (state, moves, x, y, pawn) => {\n    let v_moves = [];\n\n    // For every move in valid_moves check for check\n    for (let i = 0; i <= moves.length - 1; i++) {\n      let state_copy = JSON.parse(JSON.stringify(state));\n      let move = moves[i];\n      state_copy[move[1]][move[0]] = pawn;\n      state_copy[y][x] = \"\";\n      let color = \"b\";\n      if (pawn[0] === \"b\") {\n        color = \"w\";\n      }\n      let check = checkCheck(state_copy, color);\n      if (!check) {\n        v_moves.push(move);\n      }\n    }\n    return v_moves;\n  };\n\n  const getValidMoves = (\n    x,\n    y,\n    pawn,\n    local_game_state,\n    checking_check = false\n  ) => {\n    let valid_moves = [];\n\n    if (pawn[1] === \"P\") {\n      valid_moves = extras.pawn_valid_moves(x, y, pawn, local_game_state);\n    }\n    // For a rook\n    else if (pawn[1] === \"R\") {\n      valid_moves = extras.rook_valid_moves(x, y, pawn, local_game_state);\n    }\n    // For knight\n    else if (pawn[1] === \"K\" && pawn.length > 2) {\n      valid_moves = extras.knight_valid_moves(x, y, pawn, local_game_state);\n    } else if (pawn[1] === \"K\" && pawn.length === 2) {\n      valid_moves = extras.king_valid_moves(x, y, pawn, local_game_state);\n      // If king is in his starting position\n      // Castling might be possible\n      const c_move = extras.castling_possible(x, y, pawn, local_game_state);\n      // c_move !== undefined is a quick bug fix\n      if (c_move !== false && !checking_check && c_move !== undefined) {\n        console.log(\"add_castling_move\");\n        valid_moves.push(c_move);\n      }\n    } else if (pawn[1] === \"B\") {\n      valid_moves = extras.get_bishop_moves(x, y, pawn, local_game_state);\n    }\n    // Queen\n    else if (pawn[1] === \"Q\") {\n      // First get up, down, left, right; just like rook.\n      valid_moves = extras.rook_valid_moves(x, y, pawn, local_game_state);\n      let b_moves = extras.get_bishop_moves(x, y, pawn, local_game_state);\n      for (let i = 0; i <= b_moves.length - 1; i++) {\n        valid_moves.push(b_moves[i]);\n      }\n    }\n    return valid_moves;\n  };\n\n  const switchPawn = (x, y, pawn_x, pawn_y, pawn, next_move1) => {\n    let updated_game_state = JSON.parse(JSON.stringify(game_state));\n    updated_game_state[y][x] = pawn;\n    set_game_state(updated_game_state);\n    set_end_b(null);\n    set_end_w(null);\n\n    // After switching the pawn, make a computer move is mode is 1player\n    if (props.mode === \"1player\") {\n      const data = extras.getComputerMoveData(\n        updated_game_state,\n        comp_color,\n        getValidMoves,\n        v_moves\n      );\n      // Emit the data to the server\n      socket.emit(\"computer-move\", {\n        data: data,\n        game_state: updated_game_state,\n        comp_color: comp_color,\n      });\n      console.log(\"data emitted\", data);\n    }\n  };\n\n  const updateGameState = (\n    coor_x,\n    coor_y,\n    pawn_x,\n    pawn_y,\n    pawn,\n    l_game_state\n  ) => {\n    l_game_state[coor_y][coor_x] = pawn;\n    l_game_state[pawn_y][pawn_x] = \"\";\n    return l_game_state;\n  };\n\n  const checkCheck = (igame_state, color) => {\n    // Get all valid moves\n    // And see if anyone can eat the opponent's king\n    for (let i = 0; i <= igame_state.length - 1; i++) {\n      for (let j = 0; j <= igame_state[i].length - 1; j++) {\n        let pawn = igame_state[i][j];\n\n        if (pawn[0] === color) {\n          // When doing this don't check for castling move\n          let valid_moves1 = getValidMoves(j, i, pawn, igame_state, true);\n          for (let k = 0; k <= valid_moves1.length - 1; k++) {\n            let pawn_on_pos =\n              igame_state[valid_moves1[k][1]][valid_moves1[k][0]];\n            if (pawn_on_pos[1] === \"K\" && pawn_on_pos.length === 2) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  };\n\n  const getTagsOfValidMoves = (valid_moves) => {\n    let tags = [];\n    if (valid_moves.length > 0) {\n      for (let i = 0; i <= valid_moves.length - 1; i++) {\n        let move = valid_moves[i];\n        let y = (move[1] + 1).toString();\n        let x = letters[move[0]];\n        let tag = x + y;\n        tags.push(tag);\n      }\n    }\n    return tags;\n  };\n\n  // lg_state == local_game_state\n  const handleCheck = (color, lg_state) => {\n    // color = Color of the king that is in danger\n    set_check(color);\n\n    // Check if it checkmate\n    const mate = checkCheckmate(lg_state, color);\n\n    if (mate) {\n      let i = \"w\";\n      if (mate === \"w\") {\n        i = \"b\";\n      }\n      set_checkmate(i);\n    }\n  };\n\n  const checkCheckmate = (state, color) => {\n    // color = color of king in danger\n    // Get all possible moves and if there are no possible moves\n    // It is checkmate\n    let v_moves1 = [];\n    for (let i = 0; i <= 7; i++) {\n      for (let j = 0; j <= 7; j++) {\n        let pawn = state[i][j];\n\n        if (pawn[0] === color) {\n          const vm = getValidMoves(j, i, pawn, state);\n          let moves = v_moves(state, vm, j, i, pawn);\n          if (moves.length > 0) {\n            for (let x = 0; x <= moves.length - 1; x++) {\n              v_moves1.push(moves[x]);\n            }\n          }\n        }\n      }\n    }\n    if (v_moves1.length < 1) {\n      console.log(\"possible moves: \", v_moves1);\n      return color;\n    }\n    console.log(\"v_moves length: \", v_moves1.length);\n    return false;\n  };\n\n  const handleColorChoice = (color) => {\n    set_player_color(color);\n    console.log(\"color: \", color);\n    if (color === \"White\") {\n      set_comp_color(\"b\");\n    } else {\n      set_comp_color(\"w\");\n      // If computer if white make first move\n      const data = extras.getComputerMoveData(\n        game_state,\n        \"w\",\n        getValidMoves,\n        v_moves\n      );\n      // Emit the data to the server\n      socket.emit(\"computer-move\", {\n        game_state: game_state,\n        comp_color: \"w\",\n      });\n      console.log(\"data emitted\", data);\n    }\n  };\n\n  const handleExit = () => {\n    void 0;\n  };\n\n  // Set the board\n  let board_data = getBoardData();\n\n  return (\n    <div className=\"game\">\n      {end_w ? (\n        <PawnDialog\n          color={\"w\"}\n          open={true}\n          switchPawn={switchPawn}\n          data={end_w}\n        />\n      ) : null}\n      {end_b ? (\n        <PawnDialog\n          color={\"b\"}\n          open={true}\n          switchPawn={switchPawn}\n          data={end_b}\n        />\n      ) : null}\n      {checkmate !== false ? (\n        <CheckmateDialog\n          open={true}\n          winner={checkmate}\n          handleExit={handleExit}\n        />\n      ) : null}\n      {props.mode === \"1player\" && !comp_color && !player_color ? (\n        <ChooseColorDialog open={true} handleColorChoice={handleColorChoice} />\n      ) : null}\n      <Panel\n        mode={props.mode}\n        color={player_color}\n        set_game_state={set_game_state}\n        set_next_move={set_next_move}\n        set_check={set_check}\n        set_comp_color={set_comp_color}\n        set_player_color={set_player_color}\n        handleExit={handleExit}\n        next_move={next_move}\n        online={false}\n      />\n      <div className=\"board\">\n        <div className=\"squares\">\n          {board_data.map((row, i) => {\n            return (\n              <div className=\"board-row\" key={i}>\n                {row.map((square) => {\n                  return (\n                    <Square\n                      key={square.tag}\n                      tag={square.tag}\n                      value={getSquareValue(square.tag)}\n                      handleClick={handleClick}\n                      check={check}\n                      validMoves={getTagsOfValidMoves(valid_moves)}\n                    />\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default OfflineBoard;\n","/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/panel.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/choose_pawn.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/extras.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/square.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/checkmate_dialog.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/socket/socket.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/choose_color_dialog.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/register.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/login.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/private_route.js",[],"/Users/macbook/Desktop/Projects/react_chess/chess-client/src/components/leaderboard.js",["82","83","84","85","86","87","88","89"],{"ruleId":"90","replacedBy":"91"},{"ruleId":"92","replacedBy":"93"},{"ruleId":"94","severity":1,"message":"95","line":36,"column":25,"nodeType":"96","messageId":"97","endLine":36,"endColumn":42},{"ruleId":"94","severity":1,"message":"98","line":6,"column":8,"nodeType":"96","messageId":"97","endLine":6,"endColumn":24},{"ruleId":"94","severity":1,"message":"99","line":14,"column":10,"nodeType":"96","messageId":"97","endLine":14,"endColumn":25},{"ruleId":"94","severity":1,"message":"100","line":32,"column":9,"nodeType":"96","messageId":"97","endLine":32,"endColumn":21},{"ruleId":"94","severity":1,"message":"101","line":36,"column":9,"nodeType":"96","messageId":"97","endLine":36,"endColumn":22},{"ruleId":"102","severity":1,"message":"103","line":72,"column":11,"nodeType":"104","messageId":"105","endLine":72,"endColumn":23},{"ruleId":"106","severity":1,"message":"107","line":43,"column":6,"nodeType":"108","endLine":43,"endColumn":18,"suggestions":"109"},{"ruleId":"94","severity":1,"message":"110","line":1,"column":27,"nodeType":"96","messageId":"97","endLine":1,"endColumn":36},{"ruleId":"94","severity":1,"message":"111","line":2,"column":8,"nodeType":"96","messageId":"97","endLine":2,"endColumn":13},{"ruleId":"94","severity":1,"message":"112","line":5,"column":8,"nodeType":"96","messageId":"97","endLine":5,"endColumn":16},{"ruleId":"94","severity":1,"message":"113","line":6,"column":8,"nodeType":"96","messageId":"97","endLine":6,"endColumn":12},{"ruleId":"94","severity":1,"message":"114","line":7,"column":8,"nodeType":"96","messageId":"97","endLine":7,"endColumn":17},{"ruleId":"94","severity":1,"message":"115","line":9,"column":8,"nodeType":"96","messageId":"97","endLine":9,"endColumn":14},{"ruleId":"94","severity":1,"message":"116","line":10,"column":8,"nodeType":"96","messageId":"97","endLine":10,"endColumn":18},{"ruleId":"94","severity":1,"message":"117","line":41,"column":19,"nodeType":"96","messageId":"97","endLine":41,"endColumn":30},"no-native-reassign",["118"],"no-negated-in-lhs",["119"],"no-unused-vars","'set_opponent_name' is assigned a value but never used.","Identifier","unusedVar","'LeaderboardModal' is defined but never used.","'openLeaderboard' is assigned a value but never used.","'handleOpenLb' is assigned a value but never used.","'handleCloseLb' is assigned a value but never used.","no-dupe-keys","Duplicate key 'borderRadius'.","ObjectExpression","unexpected","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'makeComputerMove'. Either include it or remove the dependency array.","ArrayExpression",["120"],"'useEffect' is defined but never used.","'axios' is defined but never used.","'Backdrop' is defined but never used.","'Fade' is defined but never used.","'TextField' is defined but never used.","'Button' is defined but never used.","'Typography' is defined but never used.","'set_lb_data' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"121","fix":"122"},"Update the dependencies array to be: [comp_color, makeComputerMove]",{"range":"123","text":"124"},[1403,1415],"[comp_color, makeComputerMove]"]